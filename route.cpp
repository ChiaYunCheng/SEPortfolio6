/*
 * Created  by rbh, 27/02/15
 * Modified by nas, 18/12/16
 */

#include <sstream>
#include <fstream>
#include <iostream>
#include <cassert>
#include <cmath>

#include "xmlparser.h"
#include "route.h"

namespace GPXP
{
  const metres Route::granularity = 20;
  const Position Route::northPole = Position(90,0,0);

  Route::Route(string source, bool isFileName)
  {
      using namespace XML_Parser;
      using std::endl;

      if (isFileName)
      {
		  if (!(canOpenFile(source)))
		  {
			  return;
		  }
      }

	  if (checkFor(source, "gpx") && checkFor(source, "rte"))
	  {
		  source = extractContentFromElement(source, "rte");

		  getRouteName(source);

		  if (checkFor(source, "rtept"))
		  {
			  while (elementExists(source, "rtept"))
			  {
				  processNextPoint(source, "rtept");
			  }

			  oss << endl << positions.size() << " positions added";

			  calcRouteLength();

			  constructorSucceeded = true;
		  }
	  }

	  constructorReport = oss.str();
  }

  void Route::getRouteName(string & source)
  {
	  using namespace XML_Parser;

	  if (elementExists(source, "name"))
	  {
		  routeName = extractContentAndErase(source, "name");
		  oss << std::endl << "route name is " << routeName;
	  }
  }

  Position Route::getPointPosition(string rawPoint) const
  {
	  using namespace XML_Parser;

	  string lat = getElementAttribute(rawPoint, "lat");
	  string lon = getElementAttribute(rawPoint, "lon");
	  string ele = extractContentFromElement(getElementContent(rawPoint), "ele");

	  return Position(lat, lon, ele);
  }

  string Route::getPointName(string rawPoint) const
  {
	  using namespace XML_Parser;

	  string name = "";

	  if (elementExists(rawPoint, "name"))
	  {
		  name = extractContentFromElement(rawPoint, "name");
	  }

	  return name;
  }

  void Route::processNextPoint(string & source, string element)
  {
	  string point = XML_Parser::getAndEraseElement(source, element);

	  Position currentPos = getPointPosition(point);

	  if (!positions.empty())	//if not the first point
	  {
		  Position lastPos = positions.back();
		  if (distanceBetween(lastPos, currentPos) < granularity)
		  {
			  oss << std::endl << "position ignored: " << currentPos.toString();
			  return;
		  }
		  else
		  {
			  oss << std::endl << "position added: " << currentPos.toString();
		  }
	  }
	  else
	  {
		  oss << std::endl << "start position added: " << currentPos.toString();
	  }

	  positions.push_back(currentPos);
	  positionNames.push_back(getPointName(point));
  }

  void Route::calcRouteLength()
  {
	  routeLength = 0;
	  vector<Position>::const_iterator pci1, pci2;
	  pci1 = pci2 = positions.begin();
	  ++pci2;
	  for (; pci2 != positions.end(); ++pci1, ++pci2)
	  {
		  metres deltaH = distanceBetween(*pci1, *pci2);
		  metres deltaV = pci1->getElevation() - pci2->getElevation();
		  routeLength += std::sqrt(std::pow(deltaH, 2) + std::pow(deltaV, 2));
	  }
  }

  bool Route::builtOk() const
  {
      return constructorSucceeded;
  }

  string Route::buildReport() const
  {
      /* Returns the report generated by the constructor, for debugging purposes.
       */
      bool implemented = true;
      assert(implemented);
      return constructorReport;
  }

  string Route::name() const
  {
      /* Returns the name of the Route, or "Unnamed Route" if nameless.
       */
      bool implemented = true;
      assert(implemented);
      return routeName.empty() ? "Unnamed Route" : routeName;
  }

  metres Route::totalLength() const
  {
      /* Computes and returns the total length of the Route; this is
       * the sum of the distances between the successive Positions of the Route.
       */
      bool implemented = true;
      assert(constructorSucceeded);
      assert(implemented);
      return routeLength;
  }

  metres Route::netLength() const
  {
      /* Returns the distance between the first and last points on the Route.
       */
      bool implemented = true;
      assert(constructorSucceeded);
      assert(implemented);

      const Position & start  = positions.front();
      const Position & finish = positions.back();

      metres deltaH = distanceBetween(start,finish);
      metres deltaV = start.getElevation() - finish.getElevation();
      return std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
  }

  metres Route::totalHeightGain() const
  {
      /* Returns the sum of all the positive (>0) height differences between points.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  metres Route::netHeightGain() const
  {
      /* Returns the difference in elevation between the first and last points on the
       * Route.
       * Should be negative if there was a net height loss.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  degrees Route::maxUphillGradient() const
  {
      /* Returns the maximum value of gradient between successive points on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  degrees Route::maxDownhillGradient() const
  {
      /* Returns the minimum (most negative) value of gradient between successive points
       * on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  degrees Route::minLat() const
  {
      /* Returns the latitude of the most Southerly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (90.0);
  }

  degrees Route::maxLat() const
  {
      /* Returns the latitude of the most Northerly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (-90.0);
  }

  degrees Route::minLon() const
  {
      /* Returns the longitude of the most Westerly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (90.0);
  }

  degrees Route::maxLon() const
  {
      /* Returns the longitude of the most Easterly point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (-90.0);
  }

  metres Route::minEle() const
  {
      /* Returns the elevation of the lowest point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (4000);
  }

  metres Route::maxEle() const
  {
      /* Returns the elevation of the highest point on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  unsigned int Route::timesVisited(const Position & pos) const
  {
      /* Returns the number of times that the Position is visited on the Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  unsigned int Route::timesVisited(const string & nameTag) const
  {
      /* Returns the number of times that the Position with <name>nameTag</name>
       * is visited on the Route.  If nameTag == "", return 0.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  unsigned int Route::numPositions() const
  {
      /* Returns the number of Positions in this Route.
       */
      bool implemented = false;
      assert(implemented);
      return (0);
  }

  string Route::nameOf(const Position & pos) const
  {
      /* Determine whether the Position occurs anywhere on the Route,
       * and if so whether it has a name at any of the occurrences;
       * return the name if it has one, or an empty string otherwise.
       */
      bool implemented = false;
      assert(implemented);
      return (string("not implemented"));
  }

  Position Route::positionOf(const string & nameTag) const
  {
      /* This function is the inverse of Route::nameOf().  It searches on the Route
       * for a point named nameTag.  If found, its Position is returned, else the
       * North Pole Position is returned.
       */
      bool implemented = false;
      assert(implemented);
      return (northPole);
  }

  const Position & Route::operator[](unsigned int idx) const
  {
      /* Provides access to the sequence of points that make up the Route.
       * Out-of-range access should return the North Pole Position.
       */
      bool implemented = false;
      assert(implemented);
      return (northPole);
  }

  bool Route::areSameLocation(const Position & p1, const Position & p2) const
  {
      /* Determines whether the 2 Positions parameters are less than "granularity" apart.
       */
      bool implemented = true;
      assert(implemented);
      return (distanceBetween(p1,p2) < granularity);
  }

  bool Route::append(const Position & pos, const string & name)
  {
      /*  Append the position to the end of the "positions" vector, unless
       *  it is close enough to the last Position to be considered the same
       *  location (see "areSameLocation()").  The routeLength is updated
       *  accordingly.
       */
      bool implemented = true;
      assert(implemented);
      Position prevPos = positions.back();
      if (areSameLocation(pos, prevPos))
      {
          return false;
      }
      else
      {
          metres deltaH = distanceBetween(pos,prevPos);
          metres deltaV = pos.getElevation() - prevPos.getElevation();
          positions.push_back(pos);
          positionNames.push_back(name);
          routeLength += std::sqrt(std::pow(deltaH,2) + std::pow(deltaV,2));
          return true;
      }
  }

  void Route::simplify(unsigned int overridingGranularity)
  {
      /* Simplify the Route by reducing the number of points: any point in
       * the Route that differs in distance from its predecessor by less than
       * the parameter is discarded.
       */
      bool implemented = false;
      assert(implemented);
  }
}
